#!/usr/bin/env node

/**
 * Test Video Processing Pipeline
 * End-to-end test of the complete video-to-recipe processing workflow
 */

// Note: This would need TypeScript compilation or tsx to run
// For now, we'll create a simpler test that checks individual components
console.log('‚ö†Ô∏è  Note: Full pipeline test requires TypeScript compilation')
console.log('Testing individual components instead...\n')

// Test configuration
const TEST_CONFIG = {
  videoUrl: 'https://www.instagram.com/reel/DLkae8iIrLR/?utm_source=ig_web_copy_link&igsh=MzRlODBiNWFlZA==',
  options: {
    audioQuality: 'worst', // Fast processing for testing
    maxAudioDuration: 300, // 5 minutes max
    transcriptionModel: 'dimavz/whisper-tiny',
    transcriptionLanguage: 'auto',
    aiModel: 'deepseek-r1:latest',
    aiTemperature: 0.1,
    includePartialResults: true,
    enhanceWithMetadata: true,
    timeout: 300000, // 5 minutes
    skipMetadataExtraction: false
  }
}

console.log('üß™ Video Processing Pipeline Test')
console.log('================================')
console.log(`üìπ Testing URL: ${TEST_CONFIG.videoUrl}`)
console.log(`‚öôÔ∏è  Configuration:`)
console.log(JSON.stringify(TEST_CONFIG.options, null, 2))
console.log('\nüöÄ Starting pipeline test...\n')

// Track progress and timing
let lastStage = ''
let stageStartTime = Date.now()
const stageTimes = {}

function logProgress(progress) {
  // Log stage transitions
  if (progress.stage !== lastStage) {
    if (lastStage) {
      stageTimes[lastStage] = Date.now() - stageStartTime
      console.log(`   ‚úÖ ${lastStage} completed in ${stageTimes[lastStage]}ms`)
    }
    
    lastStage = progress.stage
    stageStartTime = Date.now()
    console.log(`\nüìã Stage: ${progress.stage.toUpperCase()}`)
  }

  // Log progress updates
  const progressBar = '‚ñà'.repeat(Math.floor(progress.progress / 5)) + 
                     '‚ñë'.repeat(20 - Math.floor(progress.progress / 5))
  
  console.log(`   [${progressBar}] ${progress.progress.toFixed(1)}% - ${progress.message}`)
  
  // Log sub-progress if available
  if (progress.subProgress) {
    const subBar = '‚ñì'.repeat(Math.floor(progress.subProgress.progress / 10)) + 
                   '‚ñë'.repeat(10 - Math.floor(progress.subProgress.progress / 10))
    console.log(`      ‚îî‚îÄ [${subBar}] ${progress.subProgress.stage}: ${progress.subProgress.message || 'Processing...'}`)
  }
  
  if (progress.eta) {
    console.log(`      ‚è±Ô∏è  ETA: ${progress.eta}`)
  }
}

async function runPipelineTest() {
  const overallStartTime = Date.now()
  
  try {
    console.log('üîß Pre-flight checks...')
    
    // Check system dependencies
    console.log('   üì¶ Checking system dependencies...')
    
    // Test Ollama connection
    try {
      const ollamaResponse = await fetch('http://localhost:11434/api/tags')
      if (ollamaResponse.ok) {
        const models = await ollamaResponse.json()
        console.log(`   ‚úÖ Ollama connected (${models.models?.length || 0} models available)`)
        
        // List available models
        if (models.models?.length > 0) {
          console.log('      Available models:')
          models.models.forEach(model => {
            console.log(`        - ${model.name} (${(model.size / 1024 / 1024 / 1024).toFixed(1)}GB)`)
          })
        }
      } else {
        console.warn('   ‚ö†Ô∏è  Ollama service may not be running')
      }
    } catch (error) {
      console.warn(`   ‚ö†Ô∏è  Could not connect to Ollama: ${error.message}`)
    }

    // Check yt-dlp
    const { spawn } = require('child_process')
    const ytDlpCheck = new Promise((resolve) => {
      const child = spawn('yt-dlp', ['--version'])
      child.on('close', (code) => {
        if (code === 0) {
          console.log('   ‚úÖ yt-dlp available')
        } else {
          console.warn('   ‚ö†Ô∏è  yt-dlp not found or not working')
        }
        resolve()
      })
      child.on('error', () => {
        console.warn('   ‚ö†Ô∏è  yt-dlp not found in PATH')
        resolve()
      })
    })

    // Check ffmpeg
    const ffmpegCheck = new Promise((resolve) => {
      const child = spawn('ffmpeg', ['-version'])
      child.on('close', (code) => {
        if (code === 0) {
          console.log('   ‚úÖ ffmpeg available')
        } else {
          console.warn('   ‚ö†Ô∏è  ffmpeg not found or not working')
        }
        resolve()
      })
      child.on('error', () => {
        console.warn('   ‚ö†Ô∏è  ffmpeg not found in PATH')
        resolve()
      })
    })

    await Promise.all([ytDlpCheck, ffmpegCheck])
    
    console.log('\nüöÄ Running pipeline test...\n')

    // Run the actual pipeline
    const result = await processVideoThroughPipeline(
      TEST_CONFIG.videoUrl,
      TEST_CONFIG.options,
      logProgress
    )

    // Final stage timing
    if (lastStage) {
      stageTimes[lastStage] = Date.now() - stageStartTime
      console.log(`   ‚úÖ ${lastStage} completed in ${stageTimes[lastStage]}ms`)
    }

    const totalTime = Date.now() - overallStartTime
    console.log(`\nüèÅ Pipeline test completed in ${totalTime}ms\n`)

    // Results analysis
    console.log('üìä RESULTS ANALYSIS')
    console.log('==================')
    
    console.log(`\nüéØ Overall Success: ${result.success ? '‚úÖ YES' : '‚ùå NO'}`)
    
    if (result.error) {
      console.log(`‚ùå Error: ${result.error}`)
    }

    if (result.warnings?.length > 0) {
      console.log(`\n‚ö†Ô∏è  Warnings (${result.warnings.length}):`)
      result.warnings.forEach((warning, index) => {
        console.log(`   ${index + 1}. ${warning}`)
      })
    }

    // Stage results
    console.log(`\nüìã Stage Results:`)
    Object.entries(result.stages).forEach(([stage, stageResult]) => {
      const icon = stageResult.success ? '‚úÖ' : '‚ùå'
      const time = stageResult.duration
      console.log(`   ${icon} ${stage}: ${time}ms${stageResult.error ? ` (${stageResult.error})` : ''}`)
    })

    // Quality metrics
    if (result.confidence !== undefined) {
      console.log(`\nüìà Quality Metrics:`)
      console.log(`   üéØ Confidence: ${(result.confidence * 100).toFixed(1)}%`)
      if (result.qualityScore !== undefined) {
        console.log(`   ‚≠ê Quality Score: ${(result.qualityScore * 100).toFixed(1)}%`)
      }
    }

    // Resource usage
    if (result.resourceUsage) {
      console.log(`\nüíæ Resource Usage:`)
      console.log(`   üìÅ Temp files created: ${result.resourceUsage.tempFilesCreated}`)
      console.log(`   üåê Network requests: ${result.resourceUsage.networkRequests}`)
      if (result.resourceUsage.maxMemoryUsage > 0) {
        console.log(`   üß† Max memory: ${(result.resourceUsage.maxMemoryUsage / 1024 / 1024).toFixed(1)}MB`)
      }
    }

    // Recipe results
    if (result.recipe) {
      console.log(`\nüç≥ EXTRACTED RECIPE`)
      console.log('==================')
      console.log(`üìù Title: ${result.recipe.title}`)
      
      if (result.recipe.summary) {
        console.log(`üìÑ Summary: ${result.recipe.summary}`)
      }
      
      if (result.recipe.ingredients?.length > 0) {
        console.log(`\nü•ï Ingredients (${result.recipe.ingredients.length}):`)
        result.recipe.ingredients.forEach((ingredient, index) => {
          console.log(`   ${index + 1}. ${ingredient}`)
        })
      }
      
      if (result.recipe.instructions?.length > 0) {
        console.log(`\nüë®‚Äçüç≥ Instructions (${result.recipe.instructions.length}):`)
        result.recipe.instructions.forEach((instruction, index) => {
          console.log(`   ${index + 1}. ${instruction}`)
        })
      }
      
      const metadata = []
      if (result.recipe.cookingTime) metadata.push(`‚è±Ô∏è  ${result.recipe.cookingTime} minutes`)
      if (result.recipe.servings) metadata.push(`üë• ${result.recipe.servings} servings`)
      if (result.recipe.difficulty) metadata.push(`üìä ${result.recipe.difficulty}`)
      if (result.recipe.cuisine) metadata.push(`üåç ${result.recipe.cuisine}`)
      
      if (metadata.length > 0) {
        console.log(`\nüìä Recipe Metadata: ${metadata.join(' ‚Ä¢ ')}`)
      }
      
      if (result.recipe.tags?.length > 0) {
        console.log(`üè∑Ô∏è  Tags: ${result.recipe.tags.join(', ')}`)
      }
    } else if (result.intermediateResults?.aiResult?.partialResults) {
      console.log(`\nüîÑ PARTIAL RESULTS`)
      console.log('==================')
      const partial = result.intermediateResults.aiResult.partialResults
      
      if (partial.title) console.log(`üìù Title: ${partial.title}`)
      if (partial.summary) console.log(`üìÑ Summary: ${partial.summary}`)
      
      if (partial.ingredients?.length > 0) {
        console.log(`\nü•ï Partial Ingredients (${partial.ingredients.length}):`)
        partial.ingredients.forEach((ingredient, index) => {
          console.log(`   ${index + 1}. ${ingredient}`)
        })
      }
      
      if (partial.instructions?.length > 0) {
        console.log(`\nüë®‚Äçüç≥ Partial Instructions (${partial.instructions.length}):`)
        partial.instructions.forEach((instruction, index) => {
          console.log(`   ${index + 1}. ${instruction}`)
        })
      }
    }

    // Intermediate results summary
    if (result.intermediateResults) {
      console.log(`\nüîç INTERMEDIATE RESULTS SUMMARY`)
      console.log('==============================')
      
      const { videoInfo, videoMetadata, audioResult, transcriptionResult, aiResult } = result.intermediateResults
      
      if (videoInfo) {
        console.log(`üìπ Video Info:`)
        console.log(`   Platform: ${videoInfo.platform}`)
        console.log(`   Video ID: ${videoInfo.videoId}`)
        console.log(`   URL: ${videoInfo.originalUrl}`)
        if (videoInfo.metadata?.title) console.log(`   Title: ${videoInfo.metadata.title}`)
      }
      
      if (videoMetadata) {
        console.log(`\nüé• Video Metadata:`)
        if (videoMetadata.title) console.log(`   Title: ${videoMetadata.title}`)
        if (videoMetadata.uploader) console.log(`   Uploader: ${videoMetadata.uploader}`)
        if (videoMetadata.description) console.log(`   Description: ${videoMetadata.description.substring(0, 100)}...`)
        if (videoMetadata.duration) console.log(`   Duration: ${videoMetadata.duration}s`)
      }
      
      if (audioResult) {
        console.log(`\nüéµ Audio Extraction:`)
        console.log(`   Success: ${audioResult.success}`)
        if (audioResult.duration) console.log(`   Duration: ${audioResult.duration}s`)
        if (audioResult.audioPath) console.log(`   Audio file: ${audioResult.audioPath}`)
        if (audioResult.warnings?.length > 0) {
          console.log(`   Warnings: ${audioResult.warnings.join('; ')}`)
        }
      }
      
      if (transcriptionResult) {
        console.log(`\nüó£Ô∏è  Transcription:`)
        console.log(`   Success: ${transcriptionResult.success}`)
        if (transcriptionResult.text) {
          console.log(`   Text length: ${transcriptionResult.text.length} characters`)
          console.log(`   Sample: "${transcriptionResult.text.substring(0, 150)}..."`)
        }
        if (transcriptionResult.confidence) {
          console.log(`   Confidence: ${(transcriptionResult.confidence * 100).toFixed(1)}%`)
        }
        if (transcriptionResult.language) console.log(`   Language: ${transcriptionResult.language}`)
      }
      
      if (aiResult) {
        console.log(`\nü§ñ AI Structuring:`)
        console.log(`   Success: ${aiResult.success}`)
        if (aiResult.confidence) console.log(`   Confidence: ${(aiResult.confidence * 100).toFixed(1)}%`)
        if (aiResult.reasoning) console.log(`   Reasoning: ${aiResult.reasoning}`)
        if (aiResult.modelUsed) console.log(`   Model: ${aiResult.modelUsed}`)
      }
    }

    console.log(`\nüèÜ Test completed successfully!`)
    
    return result

  } catch (error) {
    console.error(`\nüí• Test failed with error:`)
    console.error(error)
    
    console.log(`\nüìä Partial timing results:`)
    Object.entries(stageTimes).forEach(([stage, time]) => {
      console.log(`   ${stage}: ${time}ms`)
    })
    
    throw error
  }
}

// Run the test
if (require.main === module) {
  runPipelineTest()
    .then(() => {
      console.log('\n‚úÖ All tests completed successfully!')
      process.exit(0)
    })
    .catch((error) => {
      console.error('\n‚ùå Test failed:', error.message)
      process.exit(1)
    })
}

module.exports = { runPipelineTest } 